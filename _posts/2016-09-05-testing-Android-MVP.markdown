---
title: "Testing Android MVP"
layout: post
date: 2016-09-05 17:00
image: /assets/images/refactor-viewmodel.png
headerImage: false
tag:
- android
category: blog
author: miquel
description: How to make your MVP classes testable and how to test them
---
<p name="d705" id="d705" class="graf graf--p graf-after--h4">There are thousands of articles explaining the good, bad and ugly of different programming patterns for Android, sadly most of the articles found online forget to explain one last important step: Testing.</p><p name="36d4" id="36d4" class="graf graf--p graf-after--p">Choosing between one pattern or another is both a matter of personal preference and project requirements. I don’t believe MVP is superior to MVVM or a full custom solution, however its simplicity is the reason it is my pattern to-go when creating a new screen.</p><h4 name="8318" id="8318" class="graf graf--h4 graf-after--figure">MVP in four bullet points</h4><ul class="postList"><li name="ba55" id="ba55" class="graf graf--li graf-after--h4">MVP stands for Model-View-Presenter.</li><li name="a083" id="a083" class="graf graf--li graf-after--li">The “Model” is your data source, doesn’t matter if a database, network calls or a hard-coded list of objects.</li><li name="0418" id="0418" class="graf graf--li graf-after--li">The “View” is your Activity, Fragment or custom Android View. Which should just take care of displaying things and handling user interaction.</li><li name="942d" id="942d" class="graf graf--li graf-after--li">The “Presenter” is a plain old java object (POJO) that handles the communication between the View and the Model, makes any required data transformations, handles errors from the Model and tries to remove as much UX logic from the View as possible.</li></ul><h4 name="98a9" id="98a9" class="graf graf--h4 graf-after--li">Testing principles for MVP</h4><ul class="postList"><li name="c27f" id="c27f" class="graf graf--li graf-after--h4">Our main principle is that we will be using JUnit and not Espresso or any other automated testing framework.</li><li name="3afc" id="3afc" class="graf graf--li graf-after--li">The second principle is that we will test each part separately, as opposed to an integration test. So knowledge on dependency injection frameworks will be required.</li><li name="2854" id="2854" class="graf graf--li graf-after--li">Because we will be using JUnit, we will need to mock all UI components. For that we will use Robolectric.</li><li name="696e" id="696e" class="graf graf--li graf-after--li">Being familiar with Mockito will be also necessary in order to test interactions and mock classes.</li></ul><h3 name="9a57" id="9a57" class="graf graf--h3 graf-after--li">Testing the Model</h3><p name="c9da" id="c9da" class="graf graf--p graf-after--h3">Testing the Model is something we should be doing independently if we are doing MVP or no. In some cases, our Model will be a 3rd party library we can’t test, so we should be able to provide an easy to mock interface.</p><ul class="postList"><li name="4670" id="4670" class="graf graf--li graf-after--p">The Model must not hold any reference to the Presenter or the View.</li><li name="ba1a" id="ba1a" class="graf graf--li graf-after--li">The Model should be provided to the Presenter as an easy mockable Interface, specially when the Model is part of a 3rd party library.</li><li name="a748" id="a748" class="graf graf--li graf-after--li">The Model should be tested independently of the design pattern used.</li></ul><p name="3cf3" id="3cf3" class="graf graf--p graf-after--li">Example</p><p name="cc47" id="cc47" class="graf graf--p graf-after--p">Let’s follow an example for the full article. The Model is class that provides the user profile as an Observable (we don’t know if it comes from a local database or from the Internet), and it is defined with an Interface.</p><figure name="864b" id="864b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/miquelbeltran/0da4b0e967baf06dc7b3b35bf5f1eaac.js"></script></figure><p name="90ef" id="90ef" class="graf graf--p graf-after--figure">I would test this by using the TestSubscriber from RxJava and making sure that I get the expected value with no errors.</p><figure name="a29c" id="a29c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/miquelbeltran/88f19605963c1718597a5b3c2ce73941.js"></script></figure><h3 name="2577" id="2577" class="graf graf--h3 graf-after--figure">Testing the View</h3><p name="307e" id="307e" class="graf graf--p graf-after--h3">Testing the View is easier than we think, the most complex part is the Robolectric setup, but after doing it once, doing the same for all views will be easy.</p><p name="1854" id="1854" class="graf graf--p graf-after--p">Like any other MVP implementation, here we have the View Interface:</p><figure name="0ea1" id="0ea1" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/miquelbeltran/1f0dd3ef4654d6d654139fad8425736a.js"></script></figure><p name="6b1a" id="6b1a" class="graf graf--p graf-after--figure">Our example View will be a custom Android View that extends FrameLayout</p><figure name="afbb" id="afbb" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/miquelbeltran/68c1e792d9a0409e340332465fcce104.js"></script></figure><p name="61cc" id="61cc" class="graf graf--p graf-after--figure">What should we test here? EVERYTHING!</p><ul class="postList"><li name="1897" id="1897" class="graf graf--li graf-after--p">Let’s test that the View gets correctly created.</li><li name="ff74" id="ff74" class="graf graf--li graf-after--li">Let’s test that the default values are correct.</li><li name="4307" id="4307" class="graf graf--li graf-after--li">Let’s text that the user interactions get to the Presenter.</li><li name="5b49" id="5b49" class="graf graf--li graf-after--li">Let’s test that the View is doing its main task (display the UserProfile)</li></ul><p name="5c86" id="5c86" class="graf graf--p graf-after--li">And here is the test class:</p><figure name="b1f5" id="b1f5" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/miquelbeltran/de0156c2f87c850af4ef4052b9709dac.js"></script></figure><p name="5487" id="5487" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Step by Step:</strong></p><ul class="postList"><li name="b2e1" id="b2e1" class="graf graf--li graf-after--p">The top annotations is part of the Robolectric configuration. What we are telling the JUnit is to use Robolectric test runner with the standard BuildConfig (which we are not changing).</li><li name="5998" id="5998" class="graf graf--li graf-after--li">We hold an instance of our custom view, which will be testing.</li><li name="eafa" id="eafa" class="graf graf--li graf-after--li">We create a mocked Presenter using Mockito. We only want it to verify that the View is calling the Presenter when it should.</li><li name="e1f0" id="e1f0" class="graf graf--li graf-after--li">We create a new instance of the ProfileFrameLayout using the RuntimeEnviroment from Robolectric to get the context from the application.</li><li name="95ab" id="95ab" class="graf graf--li graf-after--li">We set our mocked Presenter, as we want to make sure it is called back.</li><li name="980b" id="980b" class="graf graf--li graf-after--li">TestEmpty checks two things: That the attachView method was called and that the textUsername is still empty.</li><li name="497e" id="497e" class="graf graf--li graf-after--li">TestLeaveView checks that the detachView method is called when the View obtains that Android event. In case of an Activity, you would have here onDestroy or onPause, depending on your case.</li><li name="4c39" id="4c39" class="graf graf--li graf-after--li">TestReturnToView does the same for the other event. Note that I reset the Presenter mock counters because the attachView method was called at the beginning.</li><li name="d17c" id="d17c" class="graf graf--li graf-after--li">Finally TestDisplay tests that the values we pass through the display() methods are set correctly on the TextView.</li></ul><p name="0e51" id="0e51" class="graf graf--p graf-after--li">We have covered all lines of code from our View, and it really doesn’t get more complicated than this once you start adding more and more logic and UI elements.</p><p name="52e7" id="52e7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">In summary:</strong></p><ul class="postList"><li name="7999" id="7999" class="graf graf--li graf-after--p">Provide a mocked Presenter so you can verify events and interaction thanks to Mockito.</li><li name="9ab3" id="9ab3" class="graf graf--li graf-after--li">Provide access to the internal views so you can verify their values.</li><li name="aa35" id="aa35" class="graf graf--li graf-after--li">Create an instance of your View without dependencies to the Android framework thanks to Robolectric.</li></ul><h3 name="ec02" id="ec02" class="graf graf--h3 graf-after--li">Testing the Presenter</h3><p name="ed64" id="ed64" class="graf graf--p graf-after--h3">We will test the Presenter the same way we tested the Model, with a simple JUnit test. However this time we will provide a mocked View to verify that the Presenter is communicating correctly with the View.</p><p name="ef60" id="ef60" class="graf graf--p graf-after--p">Our Presenter will receive a View and obtain the data from the Model to display it on the View.</p><figure name="2cbc" id="2cbc" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/miquelbeltran/9f9018e735e7a7c97051169dc9b2713a.js"></script></figure><p name="9c2b" id="9c2b" class="graf graf--p graf-after--figure">The example ProfilePresenter provided is not handling a lot of the RxJava Gotchas you should take care of, because for the brevity of this article they have been removed.</p><p name="b1d5" id="b1d5" class="graf graf--p graf-after--p">What we want to test here is that the Model (ProfileInteractor) and the View receive the correct calls from the Presenter. We are actually not interested in verifying the data, but if your Presenter was doing some data transformation you should test that as well.</p><p name="1bb3" id="1bb3" class="graf graf--p graf-after--p">You should test also how the Presenter will handle errors from the Model. With RxJava you can do that by returning an Observable.error(new Throwable()) from the getUserProfile().</p><figure name="d293" id="d293" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/miquelbeltran/ce4f3d062cee48223ab3640ffe268d25.js"></script></figure><p name="5114" id="5114" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Step by step:</strong></p><ul class="postList"><li name="056d" id="056d" class="graf graf--li graf-after--p">Create mocked instances of the Model and the View.</li><li name="d266" id="d266" class="graf graf--li graf-after--li">Mock the getUserProfile method output. I use when() to tell the mocked interactor to return an Observable from an empty instance of the expected result, using just() method to create it. (you could also return Observable.error() to test error handling)</li><li name="102e" id="102e" class="graf graf--li graf-after--li">Pass those to your instance of the Presenter.</li><li name="faff" id="faff" class="graf graf--li graf-after--li">The method getUserProfile gets called when the View is attached, so on our test we only need to verify that this method was called.</li><li name="c979" id="c979" class="graf graf--li graf-after--li">Same for the View, we need to verify that the method was called. And we actually don’t care about the content of what we got, that’s why I use any() as matcher.</li></ul><p name="124a" id="124a" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">In summary:</strong></p><ul class="postList"><li name="319e" id="319e" class="graf graf--li graf-after--p">Mock your Model and your View so you can verify they get the calls from your Presenter.</li><li name="548b" id="548b" class="graf graf--li graf-after--li">Fake responses from the Model to test the different scenarios. You don’t even need to use RxJava.</li></ul><h3 name="70f0" id="70f0" class="graf graf--h3 graf-after--li">Key Concepts</h3><ul class="postList"><li name="e782" id="e782" class="graf graf--li graf-after--h3">Have a mockable Model, if not, wrap it.</li><li name="6d03" id="6d03" class="graf graf--li graf-after--li">Use dependency injection to provide a mocked Presenter to your View. <strong class="markup--strong markup--li-strong">Do NOT create the Presenter inside the View.</strong></li><li name="9e92" id="9e92" class="graf graf--li graf-after--li">Test not only the outputs, but the interactions too.</li><li name="ee5b" id="ee5b" class="graf graf--li graf-after--li">Test the View life-cycle if your Presenter depend on it.</li><li name="5497" id="5497" class="graf graf--li graf-after--li">Test visual changes from your View, not only the text, but also visibility or background color if you change it.</li><li name="e438" id="e438" class="graf graf--li graf-after--li">Test how your Presenter will handle the different responses from the Model.</li></ul><p name="3c56" id="3c56" class="graf graf--p graf-after--li graf--trailing">I hope that next time you are writing an App and using the MVP programming pattern, you will do it with these concepts in mind so you will create fast unit tests.</p>

